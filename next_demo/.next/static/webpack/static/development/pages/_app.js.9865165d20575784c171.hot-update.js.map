{"version":3,"file":"static/webpack/static\\development\\pages\\_app.js.9865165d20575784c171.hot-update.js","sources":["webpack:///./store.js"],"sourcesContent":["import { createStore, applyMiddleware } from 'redux'\r\n// 用于在服务端的钩子  因为没有mock windows\r\nimport { composeWithDevTools } from 'redux-devtools-extension'\r\nimport thunk from 'redux-thunk'\r\n\r\nconst initialState = { count: 0 }\r\n\r\nconst reducer = (state = initialState, action = {}) => {\r\n  switch(action.type) {\r\n    case 'ABOUT/ADD_COUNT':\r\n      return { count: ++state.count }\r\n    default: \r\n      return state\r\n  }\r\n}\r\n\r\nexport const actions = {\r\n  addCount: () => {\r\n    return {\r\n      type: 'ABOUT/ADD_COUNT'\r\n    }\r\n  } \r\n}\r\n// 区别对待production 和 devlopment\r\nexport function makeStore(initialState, { isServer }) {\r\n  initialState || reducer()\r\n\r\n  if(isServer) {\r\n    // 服务端渲染肯定会先于持久化状态加载\r\n    return createStore(reducer, initialState, applyMiddleware(thunk))\r\n  } else {\r\n    // redux-persist 来持久化存放在 Store 里的应用状态（使用到了localstorage）\r\n    // 在服务端渲染时也可以初始化 Redux store 的状态，\r\n    // 不过这里需要防止后续客户端加载的持久化状态覆盖掉服务端初始状态。(造成闪烁问题)\r\n    const { persistReducer, persistStore } = require('redux-persist')\r\n    const storage = require('redux-persist/lib/storage').default\r\n\r\n    const persistedReducer = persistReducer({\r\n      key: 'nextjs',\r\n      storage\r\n    }, reducer)\r\n\r\n    const store = createStore(persistedReducer, initialState, composeWithDevTools(applyMiddleware(thunk)))\r\n    store.__persistor = persistStore(store)\r\n\r\n    return store\r\n  }\r\n}"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AANA;AAQA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AAEA;AACA;AACA;;;;A","sourceRoot":""}